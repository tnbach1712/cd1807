trigger:
- main

pool:
  name: Default

variables:
  azureServiceConnectionId: '6dbe17bd-2298-4cdd-9817-797ae7eedcad' #'myServiceConnection'
  projectRoot: $(System.DefaultWorkingDirectory)
  environmentName: 'test'
  backendAzureRmResourceGroupName: 'Azuredevops'
  backendAzureRmStorageAccountName: 'tfstate1063021378'
  backendAzureRmContainerName: 'tfstate'
  subscriptionID: e2c7cd99-c3c5-4a90-9109-02e7d50f8311
  ARM_CLIENT_ID: 4e11e6e8-d1d5-45eb-8c59-79544f9f17c8
  ARM_CLIENT_SECRET: dIx8Q~Xomi-Z3c0HyVClmlHhbv7PJ3mcUXKwOavb
  ARM_SUBSCRIPTION_ID: e2c7cd99-c3c5-4a90-9109-02e7d50f8311
  ARM_TENANT_ID: f958e84a-92b8-439f-a62d-4f45996b6d07
  pythonVersion: 3.8
  ACCOUNT_KEY: z2ezv7i2OYnoeWkizRcRVJA0al/38WzCzdk/B6ZC9zGH6oe2VxJelNJ4nNvoQ08Ke1mCBT8h/hjm+AStPmudpQ==
stages:
# - stage: BuildInfrastructure
#   displayName: 'Build Infrastructure'
#   jobs:
#   - job: InstallDependencies
#     displayName: 'Install Dependencies' 
#     steps:
#     - task: CmdLine@2
#       displayName: Check Terraform Installed
#       inputs:
#         script: 'echo $(terraform -v)'
#         workingDirectory: $(System.DefaultWorkingDirectory)
#     - task: CmdLine@2
#       displayName: Install Terraform if not exists
#       continueOnError: true
#       condition: failed()
#       inputs:
#         script: |
#           sudo apt-get update && sudo apt-get install -y gnupg software-properties-common
#           wget -O- https://apt.releases.hashicorp.com/gpg | \
#           gpg --dearmor | \
#           sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
#           echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \
#           https://apt.releases.hashicorp.com $(lsb_release -cs) main" | \
#           sudo tee /etc/apt/sources.list.d/hashicorp.list
#           sudo apt update
#           sudo apt-get install terraform
#         workingDirectory: $(System.DefaultWorkingDirectory)
#   - job: BuildInfra
#     dependsOn: InstallDependencies
#     steps:
#     - script: echo "Deploying Infrastructure..."
#       displayName: 'Deploy Infrastructure'
#     - task: AzureCLI@2
#       inputs:
#         azureSubscription: '$(azureServiceConnectionId)'
#         scriptType: 'bash'
#         scriptLocation: 'inlineScript'
#         inlineScript: |
#           az login --service-principal --username $(ARM_CLIENT_ID) --password $(ARM_CLIENT_SECRET) --tenant $(ARM_TENANT_ID)
#           az account set --subscription $(ARM_SUBSCRIPTION_ID)
#           az group list --output table

#     - task: TerraformInstaller@0
#       inputs:
#         terraformVersion: 'latest'
#     - script: |
#         terraform init -backend-config="storage_account_name=$(backendAzureRmStorageAccountName)" -backend-config="container_name=$(backendAzureRmContainerName)" -backend-config="access_key=$(ACCOUNT_KEY)" -backend-config="key=cicd/terraform.tfstate"
#       displayName: 'Initialize Terraform'
#       workingDirectory: $(System.DefaultWorkingDirectory)/terraform/environments/test
#     - script: |
#         terraform plan -out=tfplan
#       displayName: 'Plan Terraform Deployment'
#       workingDirectory: $(System.DefaultWorkingDirectory)/terraform/environments/test
#     - script: |
#         terraform apply -auto-approve tfplan
#       displayName: 'Apply Terraform Deployment'
#       workingDirectory: $(System.DefaultWorkingDirectory)/terraform/environments/test
#     - script: |
#         echo "Extracting output..."
#         echo $(terraform output -raw app_service_name)
#         output=$(terraform output -raw app_service_name)
#         echo "##vso[task.setvariable variable=appServiceName]$output"
#       displayName: 'Set App Service Name as Variable'
#       name: exportOutput
#       workingDirectory: $(System.DefaultWorkingDirectory)/terraform/environments/test
# - stage: BuildDeployApplication
#   dependsOn: BuildInfrastructure
#   variables:
#     appServiceName: $[ stageDependencies.BuildInfrastructure.InstallDependencies.outputs.exportOutput.appServiceName ]
#   jobs:
#   - job: BuildApp
#     steps:    
#       - script: |
#           python3 -m pip install --upgrade pip
#           python3 -m pip install setup
#           python3 -m pip install -r requirements.txt
#         workingDirectory: $(System.DefaultWorkingDirectory)/fakeAPI
#         displayName: 'myStep 1'
#       - script: |
#           export PATH=$HOME/.local/bin:$PATH
#           make install
#         workingDirectory: $(System.DefaultWorkingDirectory)/fakeAPI
#         displayName: 'myStep 2'

#       - script: |
#           export PATH=$HOME/.local/bin:$PATH
#           make install
#           make lint
#         workingDirectory: $(System.DefaultWorkingDirectory)/fakeAPI
#         displayName:  'myStep 3 - Run lint tests'

#       - task: ArchiveFiles@2
#         displayName: 'myStep 4 - Archive files'
#         inputs:
#           rootFolderOrFile: $(System.DefaultWorkingDirectory)/fakeAPI
#           includeRootFolder: false
#           archiveType: zip
#           archiveFile: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
#           replaceExistingArchive: true

#       - upload: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
#         displayName: 'myStep 5 - Upload package'
#         artifact: drop
#   - deployment: DeploymentJob
#     dependsOn: BuildApp
#     environment:
#       name: myVMLinux
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           - task: UsePythonVersion@0
#             inputs:
#               versionSpec: '$(pythonVersion)'
#             displayName: 'Use Python version'
#           - script: 'echo 123'
#           - script: 'echo $(appServiceName)'
#           - task: AzureWebApp@1
#             displayName: 'Deploy Azure Web App : flask-ml-service'
#             inputs:
#               azureSubscription: $(azureServiceConnectionId)
#               appName: myApplication-bachtn01-AppService
#               package: $(Pipeline.Workspace)/drop/$(Build.BuildId).zip
#               appType: webAppLinux
- stage: Test
  # dependsOn: BuildDeployApplication
  jobs:
  - job: JUnitTest
    steps:
    - script: "echo $(node -v)"
    - script: "echo $(npm -v)"
    - script: |
        if ! command -v nvm &> /dev/null
        then
            echo "nvm could not be found, installing..."
            # Install nvm
            # This fetches the install script from nvm's GitHub repository and executes it
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
            
            # Source nvm script to make it available in the current session
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
            [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
            
            echo "nvm installed successfully."
        else
            echo "nvm is already installed."
        fi

        # Check if npm is installed
        # Since npm comes with Node.js, we check for Node.js instead
        if ! command -v node &> /dev/null
        then
            echo "Node.js (and npm) could not be found, installing..."
            # Install Node.js and npm using nvm
            # You can specify a version to install, or use 'node' for the latest version
            nvm install 16
            
            echo "Node.js (and npm) installed successfully."
        else
            echo "Node.js (and npm) are already installed."
        fi
    - task: CmdLine@2
      displayName: Install Newman
      inputs:
        script: 'npm install -g newman'
        workingDirectory: $(System.DefaultWorkingDirectory)
    - task: CmdLine@2
      displayName: Run Data Validation Tests
      continueOnError: true
      inputs:
        script: 'newman run StarerAPIs.json'
        workingDirectory: '$(System.DefaultWorkingDirectory)/automatedtesting/postman'
    # - task: CmdLine@2
    #   displayName: Run Regression Tests
    #   continueOnError: true
    #   inputs:
    #     script: 'newman run TestSuite.Regression.json -e Test.environment.json --reporters cli,junit --reporter-junit-export TEST-Regression.xml'
    #     workingDirectory: '$(System.DefaultWorkingDirectory)/automatedtesting/postman'
    # Postman - Publish Results 
    # ToDo: Complete the task as explained here: https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/test/publish-test-results?view=azure-devops&tabs=trx%2Cyaml#yaml-snippet
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/TEST-*.xml'
        searchFolder: '$(System.DefaultWorkingDirectory)/automatedtesting/postman'
        mergeTestResults: true
        testRunTitle: testRunTitle_$(BuilBuild.BuildIdd)